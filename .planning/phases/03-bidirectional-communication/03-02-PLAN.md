---
phase: 03-bidirectional-communication
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/bidirectional/error-templates.ts
  - src/bidirectional/error-bridge.ts
autonomous: true

must_haves:
  truths:
    - "Agent errors are formatted into natural-language questions with file, code, and context"
    - "Error templates respect a configurable max length (default 2000 chars)"
    - "ErrorBridge provides a queue-compatible method for submitting errors"
  artifacts:
    - path: "src/bidirectional/error-templates.ts"
      provides: "Rich error context formatting"
      exports: ["formatErrorQuery", "truncateToLimit"]
    - path: "src/bidirectional/error-bridge.ts"
      provides: "Error-to-query bridge"
      exports: ["ErrorBridge"]
  key_links:
    - from: "src/bidirectional/error-bridge.ts"
      to: "src/bidirectional/error-templates.ts"
      via: "formatErrorQuery"
      pattern: "formatErrorQuery"
---

<objective>
Build the error bridge that captures coding agent errors and formats them as rich, contextual questions for NotebookLM. This is the input side of the error-to-resolution pipeline.

Purpose: Transforms raw error objects into well-structured natural-language queries that NotebookLM can answer effectively using uploaded documentation.
Output: Error template formatter and ErrorBridge class ready to be wired to QueryInjector in Wave 2.
</objective>

<execution_context>
@C:\Users\lucid\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\lucid\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-bidirectional-communication/03-RESEARCH.md
@src/types/bidirectional.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement error templates</name>
  <files>src/bidirectional/error-templates.ts</files>
  <action>
Create `src/bidirectional/error-templates.ts`:

- Import `AgentError` and `ErrorQueryOptions` from `../types/bidirectional.js`
- `truncateToLimit(text: string, maxLength: number): string` -- truncates with "... [truncated]" suffix
- `formatErrorQuery(error: AgentError, taskGoal: string, options?: ErrorQueryOptions): string`:
  - Build query in priority order (earlier items survive truncation):
    1. "I'm working on: {taskGoal}"
    2. "I'm getting this error: {error.message}"
    3. "In file: {error.file}:{error.line}" (if present)
    4. "Relevant code:\n{error.codeSnippet}" (if present)
    5. "I already tried:\n- {each attemptedFix}" (if present)
    6. "Technology: {error.technology}" (if present)
    7. "What's the correct approach based on the documentation?"
  - If options.includeStackTrace and error.stackTrace, append truncated stack trace
  - Apply truncateToLimit with options.maxLength (default 2000)
  - Return the formatted query string

Keep it simple -- these are string templates, not complex logic.
  </action>
  <verify>npx tsc --noEmit src/bidirectional/error-templates.ts</verify>
  <done>formatErrorQuery produces natural-language questions from AgentError objects within character limits</done>
</task>

<task type="auto">
  <name>Task 2: Implement ErrorBridge</name>
  <files>src/bidirectional/error-bridge.ts</files>
  <action>
Create `src/bidirectional/error-bridge.ts`:

- Import `AgentError`, `ErrorQueryOptions` from types
- Import `formatErrorQuery` from `./error-templates.js`
- `ErrorBridge` class:
  - Constructor takes `options?: ErrorQueryOptions` (stored as defaults)
  - `formatQuery(error: AgentError, taskGoal: string): string` -- delegates to formatErrorQuery with stored options
  - `createQueryPayload(error: AgentError, taskGoal: string): { query: string, source: 'error-bridge', error: AgentError }` -- returns structured payload ready for the query pipeline
  - Keeps a log of submitted errors: `getErrorLog(): AgentError[]`

This is a thin coordination layer. The actual query injection happens when the pipeline wires ErrorBridge output to QueryInjector (Plan 03-04).
  </action>
  <verify>npx tsc --noEmit src/bidirectional/error-bridge.ts</verify>
  <done>ErrorBridge formats errors into query payloads and maintains an error log</done>
</task>

</tasks>

<verification>
- Both files type-check clean
- formatErrorQuery output is under 2000 chars for typical errors
- ErrorBridge.createQueryPayload returns a well-structured payload
</verification>

<success_criteria>
- Error templates produce readable natural-language questions
- Max length enforcement prevents NotebookLM input overflow
- ErrorBridge provides clean API for the query pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/03-bidirectional-communication/03-02-SUMMARY.md`
</output>
