---
phase: 03-bidirectional-communication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/bidirectional.ts
  - src/bidirectional/query-injector.ts
  - src/bidirectional/deduplication.ts
autonomous: true

must_haves:
  truths:
    - "QueryInjector types a question into NotebookLM chat and returns the response"
    - "QueryDeduplicator blocks exact duplicate queries via SHA-256 hash"
    - "QueryDeduplicator blocks near-duplicate queries via Dice coefficient > 0.85"
  artifacts:
    - path: "src/types/bidirectional.ts"
      provides: "Shared types for Phase 3 (QAPair, AgentError, AgentContext, ResearchReport)"
      exports: ["QAPair", "AgentError", "AgentContext", "ResearchReport", "ErrorQueryOptions"]
    - path: "src/bidirectional/query-injector.ts"
      provides: "Query injection into NotebookLM chat"
      exports: ["QueryInjector"]
    - path: "src/bidirectional/deduplication.ts"
      provides: "Two-tier query deduplication"
      exports: ["QueryDeduplicator"]
  key_links:
    - from: "src/bidirectional/query-injector.ts"
      to: "src/browser/selectors.ts"
      via: "Selectors.chatInput, Selectors.sendButton"
      pattern: "Selectors\\.chat"
    - from: "src/bidirectional/query-injector.ts"
      to: "src/browser/humanize.ts"
      via: "humanType, humanClick"
      pattern: "humanType|humanClick"
---

<objective>
Create the core query pipeline: shared Phase 3 types, QueryInjector that types questions into NotebookLM and captures responses, and two-tier QueryDeduplicator that prevents repeat questions.

Purpose: These are the foundational components that every other Phase 3 module depends on -- types define the data shapes, injector is the core mechanism for asking NotebookLM questions, and deduplication gates all queries.
Output: Three TypeScript modules ready for import by error bridge, answer chain, and report compiler.
</objective>

<execution_context>
@C:\Users\lucid\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\lucid\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-bidirectional-communication/03-RESEARCH.md
@src/browser/selectors.ts
@src/browser/humanize.ts
@src/browser/wait.ts
@src/notebooklm/extractor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared Phase 3 types</name>
  <files>src/types/bidirectional.ts</files>
  <action>
Create `src/types/bidirectional.ts` with all shared types for Phase 3:

- `QAPair`: { question: string, answer: string, timestamp: Date, source: 'auto-expansion' | 'error-bridge' | 'manual', relevanceScore?: number, citations?: string[] }
- `AgentError`: { message: string, file?: string, line?: number, stackTrace?: string, codeSnippet?: string, attemptedFixes?: string[], technology?: string }
- `AgentContext`: { query: string, answer: string, citations: string[], confidence: 'high' | 'medium' | 'low' }
- `ResearchReport`: { sessionId: string, notebook: string, taskGoal: string, pairs: QAPair[], startTime: Date, endTime: Date }
- `ErrorQueryOptions`: { maxLength?: number (default 2000), includeStackTrace?: boolean (default false) }
- `DeduplicationResult`: { duplicate: boolean, matchedQuery?: string, similarity?: number }

Export all types. No runtime code in this file.
  </action>
  <verify>npx tsc --noEmit src/types/bidirectional.ts</verify>
  <done>All Phase 3 types exported and type-check clean</done>
</task>

<task type="auto">
  <name>Task 2: Implement QueryInjector and QueryDeduplicator</name>
  <files>src/bidirectional/query-injector.ts, src/bidirectional/deduplication.ts</files>
  <action>
**QueryInjector** (`src/bidirectional/query-injector.ts`):
- Constructor takes Playwright `Page` instance
- Creates internal `ResponseExtractor` from Phase 1
- `inject(query: string): Promise<QAPair>` method:
  1. Click chat input via `Selectors.chatInput`
  2. Clear existing text with `fill('')`
  3. Use `humanType()` from Phase 1 to type the query with realistic delays
  4. Use `humanClick()` on `Selectors.sendButton` to submit
  5. Call `waitForStreamingComplete()` from Phase 1 to wait for response
  6. Extract response via `ResponseExtractor.extractLatestResponse()`
  7. Return QAPair with question, answer, timestamp, source='manual'
- Handle errors: if input not found or send fails, throw descriptive error

**QueryDeduplicator** (`src/bidirectional/deduplication.ts`):
- Install `string-similarity` package: `npm install string-similarity && npm install -D @types/string-similarity`
- Two-tier deduplication:
  - Tier 1: SHA-256 hash of normalized query (lowercase, trimmed, punctuation-stripped, whitespace-collapsed)
  - Tier 2: Dice coefficient via `compareTwoStrings` from `string-similarity`, threshold 0.85
- `isDuplicate(query: string): DeduplicationResult`
- `record(query: string): void` -- adds to both hash set and query list
- `clear(): void` -- resets for new session
- `getRecordedQueries(): string[]` -- returns all recorded normalized queries

Use Node.js built-in `crypto` for SHA-256. Do NOT use external crypto libraries.
  </action>
  <verify>npx tsc --noEmit src/bidirectional/query-injector.ts src/bidirectional/deduplication.ts</verify>
  <done>QueryInjector can type queries and extract responses; QueryDeduplicator blocks exact and near-duplicate queries</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes for all three files
- Types are importable from `src/types/bidirectional.ts`
- QueryInjector imports and uses Phase 1 Selectors, humanize, wait, and ResponseExtractor
- QueryDeduplicator uses Node.js crypto + string-similarity
</verification>

<success_criteria>
- All Phase 3 shared types defined and exported
- QueryInjector wired to Phase 1 browser automation
- Deduplication blocks exact matches (SHA-256) and near matches (Dice > 0.85)
- All files type-check clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-bidirectional-communication/03-01-SUMMARY.md`
</output>
